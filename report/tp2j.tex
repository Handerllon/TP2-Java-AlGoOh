\input{config.tex}
%-----------------------------------%
%									%
%		Comienzo del documento		%
%									%
%-----------------------------------%
\begin{document}
%-----------------------------------%
%									%
%			Caratula				%
%									%
%-----------------------------------%
\pagestyle{fancy}
\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for horizontal lines, change thickness here
	\center % Centre everything on the page
	
	\thispagestyle{empty}
	\begin{center}
		\includegraphics[scale=1]{includes/banner_fiuba.pdf}\\
	\end{center}

	\vspace*{\stretch{1}}
	
	\textsc{\LARGE \textsc{[75.07] Algoritmos y Programación III}}
	\\[0.5cm]
	\textsc{\large 1\textsuperscript{o} Cuatrimestre 2018}
	\\[0.5cm]
	\textsc{\large Turno noche}
	\\[0.5cm]
	
	\HRule
	\\[0.5cm]
	{\huge\bfseries TP2: Al-Go-Oh}
	\\[0.2cm]
	\HRule
	\\[0.5cm]
	
	\begin{tabbing}
		\hspace{2cm}\=\+
		\underline{AUTORES}\hspace{-1cm}\=\+\hspace{1cm}\=\hspace{6cm}\=\\
		\\
		Anderson, Manuel			\>\>- \#101.230\\
		\>\footnotesize{$<$manuel121097@gmail.com$>$}\\
		\\
		Arredondo, Nicolás			\>\>- \#95.618\\
		\>\footnotesize{$<$nicolas\_arredondo@hotmail.com$>$}\\
		\\
		Husain, Ignacio Santiago	\>\>- \#90.117\\
		\>\footnotesize{$<$santiago.husain@gmail.com$>$}\\
		\\
		Parente, Gastón			 	\>\>- \#101.516 \\
		\>\footnotesize{$<$ggparente95@gmail.com$>$}\\
		\\
		\<\underline{DOCENTES}\\
		\\
		Lic. Suarez, Pablo \\
		\\
		Ing. Diego, Sánchez \\
		\\
		Srta. Marijuán, Magalí\\
		\\
		Sr. Leal Bazterrica, Matías
	\end{tabbing}

	\vspace*{\stretch{1}}

	\today

\end{titlepage}

\clearpage
\tableofcontents
%-------------------------------%
%								%
%			Seccion				%
%								%
%-------------------------------%
\clearpage
\section{Objetivo del trabajo}

En el presente trabajo práctico se desarrolla una aplicación que implementa el juego de cartas Yu-Gi-Oh! utilizando el lenguaje de programación Java. Se busca cumplir los siguientes objetivos:
\begin{itemize}
	\item realizar un análisis de la problemática planteada y su modelado mediante notación UML.
	\item aplicar la teoría de programación orientada a objetos estudiada en el curso.
	\item utilizar la técnica de desarrollo \emph{Test-Driven Development}.
	\item implementar y aplicar patrones de diseño para resolver problemas puntuales en la implementación del juego.
	\item realizar la interacción con los jugadores mediante una interfaz gráfica de usuario utilizando la plataforma JavaFX.
	\item tomar conciencia del uso del paradigma de orientación a objetos para modelar problemas que presentan una complejidad media.
\end{itemize}

\section{Supuestos}

Durante la programación de la aplicación y de las iteraciones en la comprensión del enunciado del trabajo, se realizaron varios supuestos que no estaban especificados en el mismo. Los mismos se basaron en las reglas del juego original \cite{reglas_juego}, intentando mantener la dificultad relativa del juego, y de no complicar innecesariamente la implementación. A continuación se describe cada uno de ellos.

\begin{itemize}
	\item Si la mano de un jugador tiene seis cartas (condición de mano llena), y el mismo toma una del mazo, entonces se va a descartar una carta de la mano del jugador. El descarte se realiza de forma automática y aleatoria, sin aviso al jugador. Dicha decisión se fundamenta en que nos pareció que le agrega dificultad al juego, ya que el usuario debe preveer este tipo de situación cuando planea diferentes estrategias de juego.
	
	\item No se puede realizar un ataque en el primer turno del juego, ya que el oponente correría con desventaja por no haber sido sorteado inicialmente para jugar.
	
	\item Cuando hay una carta campo, e ingresa una nueva, se desactiva la vieja y se la manda al cementerio.
	
	\item Se pueden activar todas las cartas mágicas que se quieran en la fase final.
	
	\item Cuando se requieren sacrificios, se selecciona automáticamente las cartas con la menor cantidad de estrellas 
	en el campo, y se las elimina de izquierda a derecha. Además, para que las cartas se puedan sacrificar, deben estar 
	en la región monstruo.
	
	\item Una vez utilizadas las cartas efecto, estas van al cementerio, independientemente si el efecto se efectuó. Por ejemplo, si se usa una carta Black Hole y no hay cartas en las regiones monstruo de ningún oponente, no se va a eliminar a ninguna, y la carta va a ir al cementerio. Esto simplifica la implementación, ya que no se debe verificar las condiciones particulares del juego.
	
	\item Si el jugador ataca a una carta de su oponente que se encuentra boca abajo, la misma pasa a estar boca arriba luego del cálculo de puntos de vida.
\end{itemize}

\section{Modelo de dominio}

[Explicar los elementos más relevantes del diseño. Es decir: qué
entidades se han creado, qué responsabilidades tienen asignadas, cómo
se relacionan, etc]

Debido a que las reglas de juego son independientes de la presentación gráfica a los jugadores, y por la existencia de turnos y fases, se decidió dividir la aplicación en tres componentes que interactúan entre sí y hacen uso del patrón de arquitectura/diseño Modelo-Vista-Controlador (MVC).


Modelo observa a:
Carta
notifica si hubo cambio de orientación.

Mano:
notifica si se agregó una carta.
notifica si se quitó una carta.

Mazo:
notifica si se tomó una carta.

Region:
notifica si ingresó una carta.
notifica si salió una carta.
notifica si se removieron todas las cartas.

Vista observa a:
Modelo:
notifica si sucedió alguno de los eventos que observa.
La Vista luego le pide lo que necesita a Modelo mediante la interfaz ModeloObservable.

\begin{description}

\item[Jugador] Tiene como atributos: un nombre, puntos de vida, un oponente (que tambien es de clase jugador), una region (de clase Region), un mazo (de clase Mazo) y una mano (de clase Mano). Esta clase representa a uno de los usuarios que se van a enfrentar en el juego, y tiene la responsabilidad de iniciar los ataques o acciones relacionadas con la jugabilidad.

\item[Region] Es una clase abstracta, que podrá tener como hijas 4 regiones particulares, que se detallaran a continuación. Como atributos, las clases hijas tendran: cartas (ArrayList de clase Carta), capacidad máxima, regionesANotificar(ArrayList de clase Region) y además, tendrá una referencia al jugador que tiene asociado y a su oponente. Como responsabilidad, cada una de las hijas de esta clase representará un area física del tablero de juego, donde se podrá jugar las cartas. Implementa la interfaz Notificable.

\item[RegionCampo] Albergará las cartas de tipo Campo.

\item[RegionMonstruos] Albergará las cartas de tipo Monstruo.

\item[RegionCementerio] Albergará las cartas que hayan sido destruidas.

\item[RegionMagicasYTrampas] Albergará las cartas de tipo Magicas o Trampas.

\item[Notificable] El objetivo de esta interfaz es que todas las regiones puedan avisar cuando se juega o se remueve una carta en la misma.

\item[Mazo] Tiene como atributo cartas, que es una lista del tipo Carta. El mazo, se encarga de otorgarle cartas al jugador y de mezclar.

\item[Mano] Tiene como atributo una cantidad maxima y una lista de cartas. Son las cartas que el jugador puede utilizar para jugar.

\item[Carta] Es una clase abstracta, que obligará a sus hijos a tener como atributo un nombre, un jugdor y un oponente, una orientación,  y que implementen el metodo de cambio de orientación (boca abajo o boca arriba).

\item[Orientacion] Es una clase abstracta que tendrá como hijas a OrientaciónArriba o OrientaciónAbajo, y las acciones que se puedan realizar dependeran de la misma.

\item[OrientacionArriba] Si la carta esta en este estado, puede realizar las acciones de ataque. 

\item[OrientacionAbajo] Si la carta esta en este estado, esta boca abajo por lo que no se puede usar, solo girar.

\item[CartaCampo] Es una clase abstracta que obligará a sus hijos a tener como atributos un modificador de defensa y un modificador de ataque, y además a ser capaces de activar un efecto y deshacerlo, y modificar los puntos de ataque y defensa de un monstruo.

\item[CartaMonstruo] Es una clase abstracta que obligará a sus hijos a tener como atributos puntos de ataque, puntos de defensa, puntos (los cuales cambian dependiendo si es ataque o defensa), estrellas (el nivel del monstruo), modo ( de clase Modo, puede ser ataque o defensa) y además todos los monstruos serán capaces de cambiar de modo, atacar o recibir ataque, y invocarse.

\item[CartaMagica] Es una clase abstracta que obligará a sus hijos a ser capaces de activar un efecto.

\item[CartaTrampa] Es una clase abstracta que obligará a sus hijos a ser capaces de activar un efecto al momento de recibir un ataque.

\item[Modo] Puede ser ModoAtaque o ModoDefensa, dependiendo de lo que decida el jugador y en base a eso, se podrá o no atacar, los calculos de puntos de vida a quitar seran distintos, etc.

\item[ModoAtaque] Representa uno de los estados posibles de la carta.

\item[ModoDefensa] Representa uno de los estados posibles de la carta.

\item[FabricaCartas] Contiene 4 fabricas, detalladas a continuación. Se encarga de pedirle a cada una de estas fábricas una carta.

\item[FabricaCartasMonstruo] Genera y devuelve una carta monstruo.

\item[FabricaCartasMagicas] Genera y devuelve una carta mágica.

\item[FabricaCartasTrampa] Genera y devuelve una carta trampa.

\item[FabricaCartasCampo] Genera y devuelve una carta trampa.

\item[Sacrificio] Contiene una lista de cartas a sacrificar.

\end{description}


\clearpage
\section{Diagramas de clases}

[ Varios diagramas de clases, mostrando la relación estática entre las
clases, pueden agregar todo el texto necesario para aclarar y explicar su
diseño, recuerden que la idea de todo el documento es que quede
documentado y entendible como está hecho el TP]

\subsection{Observadores}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{includes/Observadores}
	\caption{Observadores}
	\label{Observadores}
\end{figure}

Todos implementan registrar y eliminar observador, pero no se los muestra.



El diagrama de la figura 4.1, muestra como se relaciona la clase Jugador con las regiones, con el mazo y con la mano. Ademas, muestra el hecho de que las regiones, el mazo y la mano, contienen cartas. Por otro lado, un jugador, contiene una referencia de otro jugador (oponente).

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{includes/Jugador}
	\caption{Jugador y Carta}
	\label{Jugador}
\end{figure}

El diagrama de la figura 4.2, muestra los distintos tipos de regiones posibles, y como estas implementan la interfaz Notificable. La clase Region es abstracta.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{includes/areaDeJuego}
	\caption{Regiones}
	\label{areaDeJuego}
\end{figure}

El diagrama de la figura 4.3, muestra la clase abstracta Carta.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{includes/Carta}
	\caption{Carta}
	\label{Cartas}
\end{figure}

El diagrama de la figura 4.4, muestra los distintos tipos de Cartas que puede existir, y tambien el hecho de que existe una fábrica contenedora de cartas.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{includes/Carta2}
	\caption{Tipos de Cartas}
	\label{TiposCarta}
\end{figure}

El diagrama de la figura 4.5 muestra a la clase abstracta CartaMonstruo. La misma contiene un modo, y por otra parte, tendra como hijos a todos los monstruos. La clase sacrificio, conoce a las cartas monstruos gracias al jugador (que es el que decide que sacrificar) y ademas las contiene, 


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{includes/CartaMonstruo}
	\caption{Carta Monstruo}
	\label{CartaMonstruo}
\end{figure}

El diagrama de la figura 4.6 muestra las fábricas de cartas.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{includes/Fabricas}
	\caption{Fabricas}
	\label{Fabricas}
\end{figure}

\clearpage
\section{Diagramas de secuencia}

[ Varios diagramas de secuencia, mostrando la relación dinámica entre las
clases planteando una gran cantidad de escenarios que contemplen las
situaciones del trabajo práctico]

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.9]{includes/AtacarCasoMonstruoConMenosAtaqueAMonstruoConMasAtaque}
	\caption{titulo.}
	\label{AtacarCasoMonstruoConMenosAtaqueAMonstruoConMasAtaque}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.9]{includes/JugadorJuegaMonstruoQueRequiereSacrificio}
	\caption{titulo.}
	\label{JugadorJuegaMonstruoQueRequiereSacrificio}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.9]{includes/JugadorUsaCartaAgujeroNegro}
	\caption{titulo.}
	\label{JugadorUsaCartaAgujeroNegro}
\end{figure}

\section{Diagramas de paquetes}

[incluir un diagrama de paquetes para mostrar el acoplamiento de su
trabajo ]

\section{Diagramas de estado}

[Incluir diagramas de estados, mostrando tanto los estados como las
distintas transiciones de los mismos para varias entidades del trabajo
práctico ]

\section{Detalles de implementación}
[Explicar los elementos más relevantes del diseño. Es decir: qué
entidades se han creado, qué responsabilidades tienen asignadas, cómo
se relacionan, etc]




{\large\textbf{Progreso}}

\bigskip


Para hacer este trabajo práctico, utilizamos TDD para el desarrollo y, durante las dos primeras entregas, usamos como táctica de programación Pair Programming para avanzar con el modelo, con reuniones físicas o varias veces, por videoconferencia. Ya llegando al final del trabajo práctico, cuando tuvimos que implementar el MVC, dividimos las tareas en el armado de la vista, controlador, modelo e informe. 

\bigskip


{\large\textbf{Refactorizaciones}}

\bigskip

Para la realización de este trabajo práctico, nuestro modelo fue cambiando en reiteradas ocasiones e implementamos múltiples refactorizaciones. 

\medskip

En un principio, habiamos decidido en conjunto que lo ideal era no utilizar un tablero y buscamos lograr la interacción entre los dos jugadores. A medida que fuimos avanzando en la primera entrega, tuvimos complicaciones en reiteradas ocaciones y terminamos optando por utilizar el tablero, lo que nos hacía creer que todo era mas fácil. Completamos la entrega y el profesor nos ayudó y nos hizo ver que la utilización de un tablero como entidad arbitraria, no era lo mejor teniendo en cuenta el paradigma orientado a objetos. Cada objeto del juego debería comunicarse con otro para representar en mayor proporción la realidad, y no crear un arbitro que no existe. Esto rompería con el \textbf{Principio SOLID de Responsabilidad Única} (el tablero estaría encargado de todas las acciones) y además, con el \textbf{Principio de Inversión de la Dependencia}, ya que todos dependerían de esta entidad.

\medskip

Entonces, retomamos la idea de que los dos jugadores se relacionen e interactuen entre ellos. Refactorizamos para lograr eliminar el tablero, y en ese momento habíamos decidido que el ataque lo haga el jugador utilizando la carta y no que sea la carta la que atacaba al oponente. Esto tambien lo hablamos con el profesor y tomamos la decisión de que cada carta sea la que realiza el ataque y además, los efectos tambien sean implementados por cada carta. La implementación del efecto, en principio, la realizamos con una interfaz que obligaba a que todos tengan un efecto pero, como cada efecto era muy particular (recibia parametros distintos) optamos por hacer que cada clase que use efecto tenga su método diferente al resto.


\medskip


Otro asunto que nos obligo a refactorizar, fueron los sacrificios. Lo que hicimos en primer lugar, fue hacer un simple array que contenía los monstruos a sacrificar, para luego terminar creando una entidad sacrificio la cual contiene los monstruos que el usuario decide sacrificar y en el momento de la invocacion se envian al cementerio.

\medskip

Mientras desarrollabamos la segunda entrega, vimos la necesidad refactorizar nuevamente y convertir a cada tipo de carta en una clase abstracta, para que los monstruos especificos hereden de ellas y estos sean los que tengan las particularidades de cada una. Esto cumple a la perfección con el \textbf{Principio de Sustitución de Liskov}, donde todas las clases hijas (Monstruos) son cartas monstruo y las cartas monstruo, son cartas. Esto aplica para toda la relación de cartas, y cumple el principio ya que todas las clases hijas se pueden ubicar en lugar de la clase padre. 

\medskip

También refactorizamos el calculo de daño y ya no son las cartas monstruos las que restaban puntos al jugador, sino que el jugador se quita sus propios puntos de vida (Cumple con principio SOLID abierto/cerrado, la clase debe estar cerrada al exterior para su modificación, pero abierta para su extención.)

\medskip

Ya preparando la entrega final, volvimos a aplicar una refactorización que consistía en que el jugador (que hasta entonces, era el encargado de atacar y de llevar a cabo las tareas) ya no sería el encargado de implementar las estrategias de las cartas, sino que ahora ellas mismas son las que atacan y activan sus efectos. Esta refactorización, también cumple con el \textbf{Principio de Responsabilidad Única} (el jugador, da ordenes a las cartas pero no le interesa como las cumplen) 

\medskip

Una vez finalizado el modelo, comenzamos a implementar la interfaz gráfica y en principio, nuestra idea fue conectarla directamente con el modelo pero nos dimos cuenta de que el usuario iba a interactuar con mas de lo que debía. Esto rompe con el \textbf{Principio de Segregación de la Interfaz} (el cliente solo debe conocer lo que usa) y hablamos con el profesor para solucionar esto. Su recomendación fue utilizar el Patron de Diseño MVC para interactuar con el usuario.

 \bigskip

A continuación se listan los patrones de diseño utilizados, junto con las explicaciones de para que fueron usados.

 \bigskip

\begin{description}

\item[MVC] Como lo indica el nombre, utilizamos este patrón para la relación entre el Modelo, la Vista y el Controlador. -- Falta explicar y ver como lo hacemos --

\item[Observer] La vista, se encarga de observar al modelo y cada parte importante del mismo, implementa la interfaz Observable. Estos objetos observables notifican a las vistas de cambios en su comportamiento. 

\item[Factory] Utilizamos este patrón de diseño para la generación de cartas de cualquier tipo, por lo que creamos 4 fábricas (cartas mágicas, cartas trampas, cartas monstruo, cartas campo).

\item[State] Este patrón de diseño, lo utilizamos para especificar que, una carta, puede estar boca arriba o boca abajo y cambiar su estado en cualquier momento con un simple llamado. Tambien, las cartas monstruos, pueden cambiar de modo de ataque a modo de defensa y asi cambiar su estado cuando el jugador lo desee. Dependiendo del estado en el que este la carta, las acciones a realizar serán distintas.  

\item[Patron 5] Hablar cual mas hay.

\end{description}





\section{Excepciones}

[Explicar las excepciones creadas, con qué fin fueron creadas y cómo y
dónde se las atrapa explicando qué acciones se toman al respecto una vez
capturadas.]

\bigskip

{\large \raggedright \textbf{Controlador}}

\begin{description}


\item[NoEsUnaCartaParaAtacar] La carta no puede realizar ataques.

\item[CartaNoPuedeCambiarOrientacionEnTurnoActual] Su nombre lo indica a la perfección.

\item[CartaYaAtacoEnTurnoActualError] En caso de que ya se haya realizado un ataque con esa carta.

\item[JugadorNoPermitidoParaJugarError] El jugador quiere jugar en el turno del enemigo.

\item[NoEsFaseX] Existe una excepción de este tipo para cada fase con el fin de evitar que se realizen acciones indebidas para el tipo de fase.

\item[NoHayEspacioLibreEnRegionMyT] La carta no se puede colocar si la región esta llena.

\item[NoHayEspacioLibreEnRegionMonstruo] La carta no se puede colocar si la región esta llena.

\item[NoSeAtacaEnPrimerTurnoError] Prohibido atacar en el primer turno.

\item[SolicitanteNoEsPropietarioDeCartaError] Si se desea realizar una acción con la carta enemiga.

\item[YaSeMandoCartaMonstruoARegionEnTurnoActual] Solo se puede jugar un monstruo por turno.

\item[NoSePuedeAtacarError] Casos en los que no sea permitido realizar un ataque.

\end{description}

\bigskip

{\large \raggedright \textbf{Modelo}}

\begin{description}

\item[RegionSinEspacioLibre] Se desea jugar una carta en una región que ya esta totalmente ocupada.

\item[CartaInvalidaError]

\item[CartaNoExisteEnRegionError] Cuando una carta no existe en la región.

\item[ManoLlenaError] Para los casos en los que se desea agarrar una carta y esta llena la mano.

\item[CartaBocaAbajoNoPuedeAtacarError] Si se selecciona la opción de atacar con una carta boca abajo.

\item[CartaEnDefensaNoPuedeAtacarError] Si se selecciona la opción de atacar con una carta en defensa.

\item[SacrificiosInsuficientesError] Cuando se quiere invocar un monstruo que requiere sacrificio y no los hay.

\item[NoHayTresDragonesBlancosParaSacrificarError] Cuando se quiere invocar al dragón definitivo y no hay tres dragones.

\end{description}

%-------------------------------%
%								%
%			Seccion				%
%								%
%-------------------------------%
\appendix
\section{Referencias}
% Removes 'Referencias' title from 'thebibliography'.
\begingroup
\renewcommand{\section}[2]{}
\begin{thebibliography}{10}
	\bibitem{libro_fontela1} Fontela, Carlos - \emph{Programación Orientada a Objetos con Smalltalk, Java y UML.} - 3\textsuperscript{ra} edición - Versión Beta 0.6.
	
	\bibitem{fowler_model} Fowler, M. - \hyperref{https://martinfowler.com/distributedComputing/purpose.pdf}{}{}{What's a model for?}
	
	\bibitem{fowler_model} Fowler, M. - \hyperref{https://www.yugioh-card.com/en/rulebook/SD_RuleBook_EN_10.pdf}{}{}{Yu-Gi-Oh! TRADING CARD GAME rulebook}
\end{thebibliography}
\endgroup

\end{document}
